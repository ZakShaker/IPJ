# IPJ

Сейчас архитектура приложения выглядит так:
![alt text](https://github.com/ZakShaker/IPJ/blob/master/ClassDiagram-2.png)

До добавления ClassLoader-ов было так:
![alt text](https://github.com/ZakShaker/IPJ/blob/master/photo_2018-01-27_23-34-17.jpg)

**Первоначальное задание**

Необходимо разработать программу, которая получает на вход список ресурсов, содержащих текст,
 и проверяет уникальность каждого слова. Каждый ресурс должен быть обработан в отдельном потоке,
  текст не должен содержать инностранных символов, только кириллица, знаки препинания и цифры. В
   случае нахождения дубликата, программа должна прекращать выполнение с соответсвующим сообщением.
    Все ошибки должны быть корректно обработаны.
    
**Solution и структура**

Класс _UniqueWordChecker_, реализующий интерфейс _Callable_ , выполняет саму проверку, записывая в _Map_ слова и количество появлений в тексте. Если обнаруживается повтор - выполнение прекращается, и метод _Callable_ возвращает _false_. Если каждое слово в тексте уникально - _true_ .

Класс _RussianWordSymbols_ релизует интерфейс _AllowedSymbols_ и отвечет за то, какие символы считать за кириллические, что считать частью слова, а что пунктуацией.

Подкачка символов в проверяющий класс идет с помощью класса _UTF8FileReader_, реализующего интерфейс _SerialCharacterReader_.

В последствии, если понадобиться читать символы не из файлов, а, например, из строк, или другого ресурса, можно будет реализовать дополнительные классы с тем же интерфейсом _SerialCharacterReader_.
Логику подоходящих слов и символов тоже можно дополнять с интерфейсом _AllowedSymbols_.

Абстрактный класс**MultipleUniqueWordChecker**проверяет уникальность слов в нескольких ресурсах. 
Классы _ConcurrentUniqueWordChecker_ и _SynchronizedUniqueWordChecker_, наследующе его, делают это с помощью ConcurrentHashMap и Collections.Synchronized(HashMap) соответственно. Разница работы по времени каждого из них при равном количестве равных ресурсов продемонстирована в классе **Main**.


**Второй вариант с использованием ClassLoader**
Класс _UniqueWordChecker_ теперь вызывает в методе call() метод checkcUniqueness() из интерфейса __UniqueChecker__.
Этот интерфейс могут реализовать два Класса **UniqueWholeWordChecker** и **Unique10SymbolsChecker**, каждый из них будет реализовывать проверку уникльности по-своему.
НО(!), поскольку задание требует подгрузки класса с одним и тем же названием, то обе реализации выполнены в двух файлах под одним и тем же именем UniqueWholeWordChecker в двух одноименных jar-файлах, поочередно лежащих в папке word10 под именем IPJ.
Класс __UniqueWordCheckerLoader__ реализует __ClassLoader__
Класс __UniqueWordCheckerInvocationHandler__  реализует __InvocationHandler__

В Main классе мы делаем цикл и ждем, чтобы успеть поменять jar-файлы с нашим классом UniqueWholeWordChecker